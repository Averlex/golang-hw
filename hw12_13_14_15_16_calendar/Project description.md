# Проект Календарь

## Последние дополнения

Список дополнений в проекте относительно предыдущего ДЗ.

**API:**

- Без изменений

**Реализация:**

Пакет, отвечающий за работу с **RabbitMQ**, вынесен в `/pkg/rabbitmq/`.
Пакет предоставляет 4 метода. Все поддерживают контекст и являются горутино-безопасными:

- `Connect` - выполняет подключение к брокеру
  - если предполагается использование как `Consumer-only`, то проверяет наличие указанной в конфиге очереди
  - в иных случаях (`Producer-only` и `Full-client`) выполняет попытку инициализации RMQ указанными в конфиге exchange и queue (поле `topic`)
- `Close` - закрывает подключение к брокеру
- `Produce` - позволяет отправлять сообщения по заранее настроенным в соответствии с конфигом роутам
- `Consume` - создаёт канал, подписывает потребителя на очередь и редиректит сообщения в созданных канал. Если подписка на канал закрывается со стороны RMQ (например, очередь опустела), переподписывается и продолжает отправлять сообщения в тот же канал. Повторная подписка происходит через `resub_timeout`, чтобы не спамить брокер.

Поскольку **scheduler** по условию работает напрямую с БД, в реализацию storage были добавлены методы для удобства его работы (`GetEventsForNotification`, `UpdateNotifiedEvents`, `DeleteOldEvents`). Также была расширена схема БД - добавлено доп. поле `is_notified`

- События для уведомления отбираются вне зависимости от факта их наступленя: будут отобраны как старые событие, по которым не были отправлены уведомления, так и не наступившие события
- События изменяются в БД (устанавливается флаг) только после того, как уведомление отправлено в броке
- В связи с расширением схемы БД было скорректрировано поведение метода `UpdateEvents` - теперь он принудительно устанавливает флаг `is_notified = false` (полезно, если событие изменено на более позднюю дату в будущем, хотя уведомление по прошлому состоянию было отправлено)
- Интервал удаления старых событий не регулируется. Периодичность очистки задаётся в конфиге

Процесс **sender** не связан с БД - только с брокером. Читает уведомления и пишет их в логи

**Тесты:**

- Для тестирования добавлены 2 миграции. Можно обновиться с помощью: `make migrate-up` -> `make migrate-down-1` (5-я миграция, предпоследняя)
- Для проверки работоспособности переподписки следует добавить в БД события, требуемые обновления. Можно сделать через REST/gRPC ручки календаря или напрямую через БД

**Makefile:**

- В команду `make build` собирает все три сервиса
- Запуск RabbitMQ прописан сразу в `docker-compose.yaml` вместе с БД. Команда в makefile изменена с `make run-db` на `make run-third-party` (аналогично для `make stop-...`)
- Команда `make run` заменена на `make run-calendar`, `make run-scheduler` и `make run-sender` (или `make run-calendar-json`, `make run-scheduler-json` и `make run-sender-json` для json pretty-print)
- Добавлены необходимые переменные окружения. Все сервисы используют общий префикс `CALENDAR_` в переменных окружения

**Директории и файлы:**

Изменилась структура проекта:

- Пакеты `logger` и `config` (его общая для сервисов часть) переехали в `/pkg/`
- Пакеты `types`, `errors` и `dto` переехали в `/internal/`

Добавлены:

- `/cmd/scheduler/` и `/cmd/sender/` - энтрипоинты сервисов
- `/configs/scheduler/` и `/configs/sender/` - конфиги сервисов
- `/internal/config/scheduler` и `/internal/config/sender` - go-адаптеры конфигов сервисов
- `/internal/scheduler` - пакет планировщика. Во многом похож на app-слой сервиса calendar
- `/internal/sender` - пакет рассыльщика

## Дополнения в API для календаря

Список дополнений в проекте относительно предыдущего ДЗ.

**API:**

- Оставлены тестовые ручки `/` и `/hello`
- Добавлена ручка `/swagger/swagger.json` - для возможости просмотра REST API сервиса (например, на https://editor.swagger.io/?url=service_url)
- Все остальные ручки соответствуют методам хранилища, как и требуется в ТЗ

**Реализация:**

- Для реализации использован gRPC-gateway
- gRPC сервер использует интерсепторы, аналогичные мидлварам HTTP сервера (мутация контекста для логов + логирование)
- В пакет `/pkg/types/` добавлен кастомный тип `Duration` для корректного маршалинга/анмаршалинга с типом `INTERVAL` в БД

**Тесты:**

- unit-тесты для gRPC сервера реализованы
- _Для HTTP сервера тесты не писались_, т.к. использовался gRPC gateway - все ручки сгенерированы, маппинг кодов gRPC на HTTP автоматический

**Makefile:**

- В команду `make setup-tools` добавлена зависимость `grpc`: устанавливает необходимые утилиты для protobuf-кодогенрации. Аналогично, для очистки добавлена зависимость `clean-grpc`
- `make generate` запускает генерацию `gRPC` кода, gateway и всех моков проекта
- Конфигурация сервера задётся через 2 саб-конфига - `http` и `grpc` соответственно

**Директории и файлы:**

- `/api/calendar/v1/`: директория с `.proto`-файлом, `swagger`-схемой и сгенерированным пакетом. В связи с небольшим размером проекта структура осталось упрощённой
- `third_party/google/api`: вспомогательные `.proto`-файлы для кодогенерации

## Описание

Календарь — это приложение на Go для управления событиями с модульной архитектурой, включающей пакеты для конфигурации, логирования, хранения данных и других функций.

## Возможности

- Управление событиями
- Настройка через TOML-файл и переменные окружения
- Поддержка базы данных с миграциями
- In-memory хранилище
- Middleware для слоёв storage, app и server
- Логирование с использованием `slog`

## Требования

- Go (версия 1.23.0)
- Docker и Docker Compose
- golangci-lint v1.57.2
- Make

## Установка

1. Клонируйте репозиторий.
2. Убедитесь, что Docker и Docker Compose установлены.
3. Выполните `make setup-tools` для установки инструментов: `grpc`, `mockery`, `goose`, `jq`.
   - _Примечание_: утилита `jq` опциональна. С её помощью можно смотреть в терминале удобочитаемые JSON-логи

## Запуск приложения

1. Запустите базу данных: `make run-db`
2. Соберите приложение: `make build` (_опционально_)
3. Запустите приложение: `make run`

- Запуск с JSON-выводом: `make run-json`
- Проверка версии: `make version` (shortcut для флагов `-v`, `--version`)
- Справка: `make help` (shortcut для флагов `-h`, `--help`)

## Остановка сервера

- `Ctrl+C` в терминале
- Передачей любого из прерываний: `SIGINT`, `SIGTERM` или `SIGHUP`

## Конфигурация

- Файл конфигурации: `./configs/calendar/config.toml`. В файле есть подсказки ко всем полям.
- Переопределение через переменные окружения с префиксом `CALENDAR_`, например, `CALENDAR_LOGGER_LEVEL`
- Учетные данные БД задаются через `CALENDAR_STORAGE_SQL_USER` и `CALENDAR_STORAGE_SQL_PASSWORD`
- Конфигурация сервера задётся через 2 саб-конфига - `http` и `grpc` соответственно.

> [!warning] И `docker-compose.yaml`, и `Makefile` содержат:
>
> - порт БД
> - название БД
> - логин и пароль пользователя БД
>   Настройки в `docker-compose.yaml` применяются при развёртывании БД, настройки из `Makefile` - для установки нужных переменных окружения при запуске и применения миграций.
>   Нужно поддерживать их консистентность.

## Управление базой данных

- Используется Docker Compose; настройки в `docker-compose.yaml` должны соответствовать `Makefile` (порт, имя БД, пользователь, пароль).
- Управление миграциями через `goose`:
  - Применить все миграции: `make migrate-up`
  - Применить одну миграцию: `make migrate-up-1`
  - Откатить последнюю миграцию: `make migrate-down-1`

## Тестирование

- Запуск тестов: `make test`
- Быстрые тесты (_без `-race`_): `make test-fast`
- Тесты с покрытием: `make test-cover`

## Линтинг

- Установка зависимостей: `make install-lint-deps`
- Запуск линтинга: `make lint`
- Добавлен конфиг `v2` в корень проекта

## Замечания по структуре и функционалу проекта

**Структура файлов**:

- `/api/calendar/v1/`: директория с `.proto`-файлом, `swagger`-схемой и сгенерированным пакетом
- `third_party/google/api`: вспомогательные `.proto`-файлы для кодогенерации
- `/internal/config`: пакет конфигурации. Вынесен отдельно, может быть полностью переиспользован другими сервисами проекта
- `/pkg/`: DTO, ошибки и типы данных для событий с валидацией

**Функционал**:

- Логирование через `slog` с использованием DI
- Свои middleware используются каждым слоем: storage (таймауты, транзакции), app (ретраи), server (мутация контекста, логирование)
- In-memory хранилище повторяет индексы БД

## Дополнительные инструменты

- `grpc`: Кодогенерация из `.proto` файлов. Включает в себя генерацию код для сервера, клиента и `swagger`-схему
- `mockery`: Генерация моков через `make generate`
- `goose`: Миграции базы данных
- `jq`: Форматирование JSON-логов
- Очистка инструментов: `make clean-tools`. В том числе удаляет `jq`, но только в том случае, если он был установлен с помощью `Makefile`
